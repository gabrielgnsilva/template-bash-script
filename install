#!/bin/bash

#=======================================================================
# HEADER
#=======================================================================
#% NAME
#%      Script Name - A brief description of your script.
#%
#=======================================================================
#% SYNOPSIS
#+      ${scriptName} [OPTION]... [ARGUMENT]...
#+
#=======================================================================
#% DESCRIPTION
#+      A detailed description of your script goes here.
#+      You can use multiple lines to provide more information.
#+
#=======================================================================
#+ OPTIONS
#+      -h, --help          Display this help message and exit
#%
#+      -v, --version       Display version information and exit
#%
#+      -l, --log-file      Custom log file location
#%                          Regex: ^[a-zA-Z0-9_/\.-]+$

#+      -L, --log-level     Set the log level for the log file
#%                          Available options:
#%                              0 - Critical messages
#%                              1 - Critical and Error messages
#%                              2 - All of the above + Warning messages
#%                              3 - All of the above + Info messages
#%                              4 - All of the above + Debug messages
#%                              5 - All of the above + Trace messages
#%
#+      -o, --option        Do nothing
#+
#=======================================================================
#+ EXAMPLES
#%      Example usages of ${scriptName}.
#+
#+      $ ${scriptName} -L 5 -l script.log
#%          This example shows how to use the script
#%          with the log level 5 option and output the logs to a file
#%          named "script.log".
#+
#=======================================================================
#/ IMPLEMENTATION
#-      Version     ${scriptName} 1.0
#/      Author      Gabriel Nascimento
#/      Copyright   Copyright (c) Gabriel Nascimento (gnsilva.com)
#/      License     MIT License
#/
#=======================================================================
#) COPYRIGHT
#)      Copyright (c) 2023 Gabriel Nascimento:
#)      <https://opensource.org/licenses/MIT>.
#)
#)      Permission is hereby granted, free of charge, to any person
#)      obtaining a copy of this software and associated documentation
#)      files (the "Software"), to deal in the Software without
#)      restriction, including without limitation the rights to use,
#)      copy, modify, merge, publish, distribute, sublicense, and/or
#)      sell copies of the Software, and to permit persons to whom the
#)      Software is furnished to do so, subject to the following
#)      conditions:
#)
#)      The above copyright notice and this permission notice shall be
#)      included in all copies or substantial portions of the Software.
#)
#)      THE SOFTWARE IS PROVIDED "AS IS," WITHOUT WARRANTY OF ANY KIND,
#)      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#)      OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#)      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#)      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#)      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#)      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#)      OTHER DEALINGS IN THE SOFTWARE.
#)
#=======================================================================
# UTILS
#       Script "utils/_checkDependencies.sh"
#           Check if a given package exists
#
#       Script "utils/_create.sh"
#           Creates a file or a folder, if it does not exist
#
#       Script "utils/_doCountdown.sh"
#           Perform a countdown for the specified number of seconds
#
#       Script "utils/_displayHelp.sh"
#           Handles the help messages, either full or usage,
#           from the info on this header
#
#       Script "utils/_logFile.sh"
#           Handles logging
#
#       Script "utils/_validateArguments.sh"
#           Used to validate a string or argument
#
#       Script "utils/_hasWritePermission.sh"
#           Check if user has write permission on a given folder
#
#=======================================================================
# DEBUG OPTIONS
    set +o xtrace
#       Trace the execution of the script (DEBUG)

    set +o noexec
#       Don't execute commands (Ignored by interactive shells)
#
#=======================================================================
# BASH OPTIONS
    set -o nounset  # Exposes unset variables
    set -o errexit  # Exit upon error, avoiding cascading errors
    set -o pipefail  # Unveils hidden failures
    set -o noclobber  # Avoid overwriting files (eg: echo "hi" > foo)
    set -o errtrace  # Inherit trap on ERR to functions and commands
    shopt -s nullglob  # Non-matching globs are removed ('*.foo' => '')
    shopt -s failglob  # Non-matching globs throw errors
    shopt -u nocaseglob  # Case insensitive globs
    shopt -s dotglob  # Wildcards match hidden files
    shopt -s globstar  # Recursive matches ('a/**/*.e' => 'a/b/c/d.e')
#
#=======================================================================
# TRAPS
    trap "" SIGTSTP  # Disable CTRL_Z
#
#=======================================================================
#: END_OF_HEADER
#=======================================================================

# Section: Script Init

# shellcheck disable=1090
function scriptInit() {

    IFS=$' \t\n'

    currentDir="${PWD}"

    scriptParams="${*}"
    scriptName="$(basename "${0}")"
    scriptDir="$(cd "$(dirname "${0}")" && pwd )"
    scriptPath="${scriptDir:?}/${scriptName:?}"
    scriptHead=$(grep --no-messages --line-number "^#: END" "${0}" \
        | head -1 \
        | cut --fields=1 --delimiter=:
    )

    scriptTempDir=$(mktemp --directory -t tmp.XXXXXXXXXX)
    scriptTempFile=$(mktemp --directory -t tmp.XXXXXXXXXX)

    scriptLogLevel=3
    scriptLogFile="${scriptDir}"/logs/script.log

    msgInvalid="${scriptName}: invalid option"
    msgTryHelp="Try '${scriptName} --help' for more information."

    mkdir --parents "$(dirname "${scriptLogFile}")" \
        || { local exitCode="${?}"
             printf "\nFailed to create log file: " >&2
             printf "\"%s\"" "${scriptLogFile}" >&2
             printf "\nMake sure it is a valid path and " >&2
             printf "that you have write permission.\n" >&2
             exit "${exitCode}"
           }

    local util
    for util in "${scriptDir}"/utils/_*.sh; do
        source "${util}"
    done
}

function trappers() {

    if [[ "${#}" -lt 1 ]]; then
        printf "trappers: missing argument\n" >&2
        printf "\nOPTIONS\n%s" "--on  Enable Trappers" >&2
        printf "\n%s\n" "--off Disable Trappers\n" >&2
        exit 1
    fi

    if [[ ! "${1:-}" =~ ^(--on|--off)$ ]]; then
        printf "\ntrappers: Invalid argument\n" >&2
        printf "\nOPTIONS\n%s" "--on  Enable Trappers" >&2
        printf "\n%s\n" "--off Disable Trappers\n" >&2
        exit 1
    fi

    local status="${1:-}"
    case "${status}" in
        --on )
            trap ctrlC INT  # Trap CTRL_C and call ctrlC
            trap errTrapper ERR  # Trap ERR and call errTrapper
            trap exitTrapper EXIT  # Trap EXIT on exitTrapper
            ;;
        --off )
            trap "" INT  # Disable trap on CTRL_C
            trap "" ERR  # Disable trap on ERR
            trap "" EXIT  # Disable trap on EXIT
            ;;
    esac
}

function ctrlC() {

    trappers --off  # Disable trappers to prevent recursion

    { printf "Interrupt signal intercepted! Exiting now...\n"
    } >> "${scriptLogFile}" 2>&1

    exit 130
}

function errTrapper() {

    local exitCode="${?}"

    trappers --off  # Disable trappers to prevent recursion

    { printf "An exception ocurred near line: %s\n" "${BASH_LINENO[0]}"
      printf "Script Parameters: '%s'\n" "${scriptParams}"
    } >> "${scriptLogFile}" 2>&1

    exit "${exitCode}"
}

function exitTrapper {

    local exitCode="${?}"
    local exitTime

    trappers --off  # Disable trappers to prevent recursion

    rm --recursive --force \
        "${scriptTempDir}" \
        "${scriptTempFile}"

    cd "${currentDir}"

    exitTime="$(date +"%Y/%m/%d %H:%M:%S")"
    { printf "[%s] [-]: Script terminated with exit status: " "${exitTime}"
      printf "%s\n" "${exitCode:-1}"
    } >> "${scriptLogFile}" 2>&1

    exit "${exitCode:-1}"
}

# Section: Script Functions

#TODO Define script functions here
# ...

# Section: Main Program

# shellcheck disable=SC1091
function main() {

    if [[ "${#}" -lt 1 ]]; then
        displayHelpUsage
        exit 0
    fi

    local i
    for i in "${@}"; do
        case "${i}" in
            -h | --help | help )
                displayFullHelp
                exit 0
                ;;
            -v | --version | version )
                displayVersion
                exit 0
                ;;
        esac
    done

    while [[ "${#}" -gt 0 ]]; do
        case "${1:-}" in
            -l | --log-file )
                shift
                local filePath="${1:-}"
                local filename
                local directory

                if [[ -z "${filePath}" ]]; then
                    printf "%s: missing file operand\n" "${scriptName}" >&2
                    printf "%s\n" "${msgTryHelp}" >&2
                    exit 1
                fi

                directory=$(dirname "${filePath}" 2>/dev/null)
                if [[ ! "${directory}" =~ ^/ ]]; then
                    directory="${PWD?}/${directory}"
                fi

                if [[ ! "${directory}" =~ ^[a-zA-Z0-9_/\.-]+$ ]]; then
                    printf "%s: Invalid directory name\n" "${scriptName}" >&2
                    printf "%s\n" "${msgTryHelp}" >&2
                    exit 1
                fi

                filename=$(basename "${filePath}")
                if [[ ! "${filename}" =~ ^[a-zA-Z0-9_/\.-]+$ ]]; then
                    printf "%s: Invalid filename\n" "${scriptName}" >&2
                    printf "%s\n" "${msgTryHelp}" >&2
                    exit 1
                fi

                if ! hasWritePermission "${directory}"; then
                    printf "%s: " "${scriptName}" >&2
                    printf "cannot set log directory to " >&2
                    printf "\"%s\"" "${directory}" >&2
                    printf ": Permission Denied\n" >&2
                    exit 1
                fi

                mkdir "${directory}" --parents          \
                    && touch "${directory?}/${filename}" \

                scriptLogFile="${filePath}"
                ;;
            -L | --log-level )
                shift
                if [[ ! "${1:-}" =~ ^(0|1|2|3|4|5)$ ]]; then
                    printf "%s: Invalid log level\n" "${scriptName}" >&2
                    printf "%s\n" "${msgTryHelp}" >&2
                    exit 1
                fi
                scriptLogLevel="${1}"
                ;;
            -o | --option )
                :
                ;;
            * )
                printf "%s \"%s\"\n" "${msgInvalid}" "${1:-}" >&2
                printf "%s\n" "${msgTryHelp}" >&2
                exit 1
                ;;
        esac
        shift
    done

    #TODO Define options logic here
    # ...

    # The trapper must be enabled after the initial setup.
    trappers --on

    # From this point on, it should be safe to use the logFile
    logFile --type=trace "Origin cwd: '${currentDir}'."
    logFile --type=trace "Header size: ${scriptHead}."
    logFile --type=trace "Script's name: '${scriptName}'."
    logFile --type=trace "Script's directory: '${scriptDir}'."
    logFile --type=trace "Script's path: '${scriptPath}'."
    logFile --type=trace "Script's param: '${scriptParams}'."
    logFile --type=trace "Script's log file: '${scriptLogFile}'."
    logFile --type=trace "Script's log level: ${scriptLogLevel}."
    logFile --type=trace "Temporary directory: '${scriptTempDir}'."
    logFile --type=trace "Temporary file: '${scriptTempFile}'."

    cd "${scriptDir}" || exit 1

    #TODO Define script logic from here
    # ...
}

# Invoke main with args only if not sourced
if ! (return 0 2> /dev/null); then
    scriptInit "${@}"
    main "${@}"
fi
